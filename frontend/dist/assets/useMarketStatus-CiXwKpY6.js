import{r as s}from"./vendor-react-CCyQGCED.js";import{y as x,M as F}from"./index-NHrG-O_Z.js";function L({symbols:n,mode:f="LTP",enabled:o=!0,autoReconnect:g=!0}){const u=x(),l=s.useRef(u?.manager??F.getInstance()),[a,t]=s.useState(new Map),[e,i]=s.useState({isConnected:u?.isConnected??!1,isAuthenticated:u?.isAuthenticated??!1,isPaused:u?.isPaused??!1,isFallbackMode:u?.isFallbackMode??!1,error:u?.error??null}),[c,h]=s.useState(!1),k=s.useMemo(()=>n.map(d=>`${d.exchange}:${d.symbol}`).sort().join(","),[n]);s.useEffect(()=>{l.current.setAutoReconnect(g)},[g]),s.useEffect(()=>l.current.addStateListener(r=>{i({isConnected:r.isConnected,isAuthenticated:r.isAuthenticated,isPaused:r.isPaused,isFallbackMode:r.isFallbackMode,error:r.error}),h(r.connectionState==="connecting"||r.connectionState==="authenticating")}),[]),s.useEffect(()=>{if(!o||n.length===0){t(new Map);return}const d=l.current;!e.isConnected&&!e.isPaused&&d.connect();const y=[];for(const{symbol:r,exchange:M}of n){const _=d.subscribe(r,M,f,m=>{t(b=>{const p=`${m.exchange}:${m.symbol}`,w=new Map(b);return w.set(p,m),w})});y.push(_);const C=d.getCachedData(r,M);if(C){const m=`${M}:${r}`;t(b=>{const p=new Map(b);return p.set(m,C),p})}}return()=>{y.forEach(r=>r())}},[o,k,f]);const S=s.useCallback(async()=>{await l.current.connect()},[]),D=s.useCallback(()=>{l.current.disconnect()},[]);return{data:a,isConnected:e.isConnected,isAuthenticated:e.isAuthenticated,isConnecting:c,isPaused:e.isPaused,isFallbackMode:e.isFallbackMode,error:e.error,connect:S,disconnect:D}}async function P(){return(await(await fetch("/auth/csrf-token",{credentials:"include"})).json()).csrf_token}function T(){const[n,f]=s.useState({timings:[],holidays:[],isLoading:!0,error:null});s.useEffect(()=>{(async()=>{try{const e={"X-CSRFToken":await P(),"Content-Type":"application/json"},[i,c]=await Promise.all([fetch("/admin/api/timings",{headers:e,credentials:"include"}),fetch("/admin/api/holidays",{headers:e,credentials:"include"})]),h=await i.json(),k=await c.json();f({timings:h.status==="success"?h.market_status||[]:[],holidays:k.status==="success"?k.data||[]:[],isLoading:!1,error:null})}catch(t){f(e=>({...e,isLoading:!1,error:`Failed to fetch market status: ${t}`}))}})()},[]);const o=s.useCallback(a=>{const t=new Date().toISOString().split("T")[0],e=n.holidays.find(i=>i.date===t);if(!e)return!1;if(e.closed_exchanges.includes(a)){const i=e.open_exchanges.find(c=>c.exchange===a);if(i){const c=Date.now();return!(c>=i.start_time&&c<=i.end_time)}return!0}return!1},[n.holidays]),g=s.useCallback(a=>{if(o(a))return!1;const t=n.timings.find(i=>i.exchange===a);if(!t)return!1;const e=Date.now();return e>=t.start_time&&e<=t.end_time},[n.timings,o]),u=s.useCallback(()=>n.timings.some(a=>{const t=Date.now();return t>=a.start_time&&t<=a.end_time&&!o(a.exchange)}),[n.timings,o]),l=s.useCallback(a=>{if(o(a))return"closed";const t=n.timings.find(c=>c.exchange===a);if(!t)return"closed";const e=Date.now(),i=900*1e3;return e<t.start_time-i?"closed":e<t.start_time?"pre-market":e<=t.end_time?"open":"post-market"},[n.timings,o]);return{isMarketOpen:g,isAnyMarketOpen:u,isHolidayForExchange:o,getMarketStatus:l,timings:n.timings,holidays:n.holidays,isLoading:n.isLoading,error:n.error}}export{L as a,T as u};
