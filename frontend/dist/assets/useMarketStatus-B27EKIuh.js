import{r as e}from"./vendor-react-RhKMXzW9.js";async function A(){return(await(await fetch("/auth/csrf-token",{credentials:"include"})).json()).csrf_token}function P({symbols:n,mode:y="LTP",enabled:i=!0,autoReconnect:S=!0}){const[M,C]=e.useState(new Map),[r,s]=e.useState(!1),[t,c]=e.useState(!1),[u,g]=e.useState(!1),[_,k]=e.useState(null),p=e.useRef(null),b=e.useRef(null),R=e.useRef(new Set),T=e.useRef([]),$=e.useCallback(async()=>A(),[]),D=e.useCallback(m=>{if(!p.current||p.current.readyState!==WebSocket.OPEN||!t){T.current=m;return}const o=m.filter(l=>{const h=`${l.exchange}:${l.symbol}`;return!R.current.has(h)});o.length!==0&&(p.current.send(JSON.stringify({action:"subscribe",symbols:o,mode:y})),o.forEach(l=>{const h=`${l.exchange}:${l.symbol}`;R.current.add(h),C(d=>{const a=new Map(d);return a.has(h)||a.set(h,{symbol:l.symbol,exchange:l.exchange,data:{}}),a})}))},[t,y]),F=e.useCallback(m=>{try{const o=JSON.parse(m.data);switch(o.type||o.status){case"auth":o.status==="success"?(c(!0),k(null),T.current.length>0&&setTimeout(()=>{D(T.current),T.current=[]},100)):k(`Authentication failed: ${o.message}`);break;case"market_data":{const h=o.symbol.toUpperCase(),d=o.exchange,a=o.data||{},O=`${d}:${h}`;C(w=>{const j=w.get(O);if(!j)return w;const W=new Map(w),f={...j.data};return Object.assign(f,{ltp:a.ltp??f.ltp,open:a.open??f.open,high:a.high??f.high,low:a.low??f.low,close:a.close??f.close,volume:a.volume??f.volume,change:a.change??f.change,change_percent:a.change_percent??f.change_percent,timestamp:a.timestamp??f.timestamp}),W.set(O,{...j,data:f,lastUpdate:Date.now()}),W});break}case"subscribe":break;case"error":k(`WebSocket error: ${o.message}`);break}}catch{}},[D]),x=e.useCallback(async()=>{if(p.current?.readyState!==WebSocket.OPEN){g(!0),k(null);try{const m=await $(),l=await(await fetch("/api/websocket/config",{headers:{"X-CSRFToken":m},credentials:"include"})).json();if(l.status!=="success")throw new Error("Failed to get WebSocket configuration");const h=l.websocket_url,d=new WebSocket(h);d.onopen=async()=>{s(!0),g(!1);try{const a=await $(),w=await(await fetch("/api/websocket/apikey",{headers:{"X-CSRFToken":a},credentials:"include"})).json();w.status==="success"&&w.api_key?d.send(JSON.stringify({action:"authenticate",api_key:w.api_key})):k("No API key found - please generate one at /apikey")}catch(a){k(`Authentication error: ${a}`)}},d.onclose=a=>{s(!1),g(!1),c(!1),R.current.clear(),S&&!a.wasClean&&i&&(b.current=setTimeout(x,3e3))},d.onerror=()=>{k("WebSocket connection error"),g(!1)},d.onmessage=F,p.current=d}catch(m){k(`Connection failed: ${m}`),g(!1)}}},[$,F,S,i]),E=e.useCallback(()=>{b.current&&(clearTimeout(b.current),b.current=null),p.current&&(p.current.close(1e3,"User disconnect"),p.current=null),s(!1),c(!1),R.current.clear()},[]);return e.useEffect(()=>(i&&n.length>0&&!r&&!u&&x(),()=>{b.current&&clearTimeout(b.current)}),[i,n.length,r,u,x]),e.useEffect(()=>{t&&n.length>0&&D(n)},[t,n,D]),e.useEffect(()=>()=>{E()},[E]),{data:M,isConnected:r,isAuthenticated:t,isConnecting:u,error:_,connect:x,disconnect:E}}async function L(){return(await(await fetch("/auth/csrf-token",{credentials:"include"})).json()).csrf_token}function I(){const[n,y]=e.useState({timings:[],holidays:[],isLoading:!0,error:null});e.useEffect(()=>{(async()=>{try{const t={"X-CSRFToken":await L(),"Content-Type":"application/json"},[c,u]=await Promise.all([fetch("/api/market-timings",{headers:t,credentials:"include"}),fetch("/api/holidays",{headers:t,credentials:"include"})]),g=await c.json(),_=await u.json();y({timings:g.status==="success"?g.data||[]:[],holidays:_.status==="success"?_.data||[]:[],isLoading:!1,error:null})}catch(s){y(t=>({...t,isLoading:!1,error:`Failed to fetch market status: ${s}`}))}})()},[]);const i=e.useCallback(r=>{const s=new Date().toISOString().split("T")[0],t=n.holidays.find(c=>c.date===s);if(!t)return!1;if(t.closed_exchanges.includes(r)){const c=t.open_exchanges.find(u=>u.exchange===r);if(c){const u=Date.now();return!(u>=c.start_time&&u<=c.end_time)}return!0}return!1},[n.holidays]),S=e.useCallback(r=>{if(i(r))return!1;const s=n.timings.find(c=>c.exchange===r);if(!s)return!1;const t=Date.now();return t>=s.start_time&&t<=s.end_time},[n.timings,i]),M=e.useCallback(()=>n.timings.some(r=>{const s=Date.now();return s>=r.start_time&&s<=r.end_time&&!i(r.exchange)}),[n.timings,i]),C=e.useCallback(r=>{if(i(r))return"closed";const s=n.timings.find(u=>u.exchange===r);if(!s)return"closed";const t=Date.now(),c=900*1e3;return t<s.start_time-c?"closed":t<s.start_time?"pre-market":t<=s.end_time?"open":"post-market"},[n.timings,i]);return{isMarketOpen:S,isAnyMarketOpen:M,isHolidayForExchange:i,getMarketStatus:C,timings:n.timings,holidays:n.holidays,isLoading:n.isLoading,error:n.error}}export{P as a,I as u};
