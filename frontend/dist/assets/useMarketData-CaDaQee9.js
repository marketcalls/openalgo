import{r as t}from"./vendor-react-RhKMXzW9.js";async function P(){return(await(await fetch("/auth/csrf-token",{credentials:"include"})).json()).csrf_token}function F({symbols:f,mode:m="LTP",enabled:g=!0,autoReconnect:D=!0}){const[W,M]=t.useState(new Map),[S,C]=t.useState(!1),[p,R]=t.useState(!1),[T,k]=t.useState(!1),[A,o]=t.useState(null),u=t.useRef(null),h=t.useRef(null),d=t.useRef(new Set),y=t.useRef([]),$=t.useCallback(async()=>P(),[]),b=t.useCallback(i=>{if(!u.current||u.current.readyState!==WebSocket.OPEN||!p){y.current=i;return}const n=i.filter(s=>{const r=`${s.exchange}:${s.symbol}`;return!d.current.has(r)});n.length!==0&&(u.current.send(JSON.stringify({action:"subscribe",symbols:n,mode:m})),n.forEach(s=>{const r=`${s.exchange}:${s.symbol}`;d.current.add(r),M(c=>{const e=new Map(c);return e.has(r)||e.set(r,{symbol:s.symbol,exchange:s.exchange,data:{}}),e})}))},[p,m]),N=t.useCallback(i=>{try{const n=JSON.parse(i.data);switch(n.type||n.status){case"auth":n.status==="success"?(R(!0),o(null),y.current.length>0&&setTimeout(()=>{b(y.current),y.current=[]},100)):o(`Authentication failed: ${n.message}`);break;case"market_data":{const r=n.symbol.toUpperCase(),c=n.exchange,e=n.data||{},E=`${c}:${r}`;M(l=>{const _=l.get(E);if(!_)return l;const O=new Map(l),a={..._.data};return Object.assign(a,{ltp:e.ltp??a.ltp,open:e.open??a.open,high:e.high??a.high,low:e.low??a.low,close:e.close??a.close,volume:e.volume??a.volume,change:e.change??a.change,change_percent:e.change_percent??a.change_percent,timestamp:e.timestamp??a.timestamp}),O.set(E,{..._,data:a,lastUpdate:Date.now()}),O});break}case"subscribe":break;case"error":o(`WebSocket error: ${n.message}`);break}}catch{}},[b]),w=t.useCallback(async()=>{if(u.current?.readyState!==WebSocket.OPEN){k(!0),o(null);try{const i=await $(),s=await(await fetch("/api/websocket/config",{headers:{"X-CSRFToken":i},credentials:"include"})).json();if(s.status!=="success")throw new Error("Failed to get WebSocket configuration");const r=s.websocket_url,c=new WebSocket(r);c.onopen=async()=>{C(!0),k(!1);try{const e=await $(),l=await(await fetch("/api/websocket/apikey",{headers:{"X-CSRFToken":e},credentials:"include"})).json();l.status==="success"&&l.api_key?c.send(JSON.stringify({action:"authenticate",api_key:l.api_key})):o("No API key found - please generate one at /apikey")}catch(e){o(`Authentication error: ${e}`)}},c.onclose=e=>{C(!1),k(!1),R(!1),d.current.clear(),D&&!e.wasClean&&g&&(h.current=setTimeout(w,3e3))},c.onerror=()=>{o("WebSocket connection error"),k(!1)},c.onmessage=N,u.current=c}catch(i){o(`Connection failed: ${i}`),k(!1)}}},[$,N,D,g]),x=t.useCallback(()=>{h.current&&(clearTimeout(h.current),h.current=null),u.current&&(u.current.close(1e3,"User disconnect"),u.current=null),C(!1),R(!1),d.current.clear()},[]);return t.useEffect(()=>(g&&f.length>0&&!S&&!T&&w(),()=>{h.current&&clearTimeout(h.current)}),[g,f.length,S,T,w]),t.useEffect(()=>{p&&f.length>0&&b(f)},[p,f,b]),t.useEffect(()=>()=>{x()},[x]),{data:W,isConnected:S,isAuthenticated:p,isConnecting:T,error:A,connect:w,disconnect:x}}export{F as u};
